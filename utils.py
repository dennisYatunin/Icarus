from os import urandom
from os.path import isfile
from hashlib import sha512
from uuid import uuid4
from sqlite3 import connect
from random import choice, random, randint
from csv import reader, Sniffer

def get_secret_key():
	'''Returns a key that may be used to secure a Flask session

	The key is a 32-character string generated with the os.urandom function.
	'''
	return urandom(32)

def initialize_database():
	'''Creates the tables in the database

	If the app is being run for the first time, the administrators, students,
	teachers, and sections tables are created; also, the data for the username
	'admin' and password '' is inserted into the administrators table.
	'''
	if not isfile('data.db'):
		conn = connect('data.db')
		c = conn.cursor()
		q = 'CREATE TABLE administrators \
		( \
			name TEXT, salt INT, hash_value INT \
			)'
		c.execute(q)
		q = 'INSERT INTO administrators (rowid, name, salt, hash_value) \
		VALUES (?, ?, ?, ?)'
		c.execute(q, (1, 'admin', '', sha512('').hexdigest()))
		q = 'CREATE TABLE students \
		( \
			id TEXT UNIQUE, name TEXT, salt INT, hash_value INT, \
			email TEXT, dob TEXT, address TEXT, phone TEXT, \
			level TEXT, cursched TEXT, pastscheds TEXT \
			)'
		c.execute(q)
		q = 'CREATE TABLE teachers \
		( \
			id TEXT UNIQUE, name TEXT, salt INT, hash_value INT, \
			email TEXT, dob TEXT, address TEXT, phone TEXT, \
			level TEXT, cursched TEXT, pastscheds TEXT \
			)'
		c.execute(q)
		q = 'CREATE TABLE sections \
		( \
			id TEXT UNIQUE, className TEXT, teacherId TEXT, pd TEXT \
			)'
		c.execute(q)

def check_login_info(username, password, table):
	'''Returns whether the database contains a user with the given information

	Checks the students, teachers, or administrators table for a user matching
	the given username and password.
	'''
	conn = connect('data.db')
	c = conn.cursor()
	q = 'SELECT salt, hash_value FROM %s WHERE name = ?' % table
	salt_n_hash = c.execute(q, (username,)).fetchone()
	# If the username does not exist, return false.
	if not salt_n_hash:
		return False
	# If the password is wrong, return false.
	if (
		sha512((password + salt_n_hash[0]) * 10000).hexdigest() != salt_n_hash[1]
		):
		return False
	# Finally, return true.
	return True

def csvHeader(hasName, hasID, hasLevel, hasEmail, hasDOB, hasAddress, hasPhone):
	'''Creates a header for the randomly-generated csv file
	'''
	s = ''
	if hasName:
		s += 'name, '
	if hasID:
		s += 'id, '
	if hasLevel:
		s += 'level, '
	if hasEmail:
		s += 'email, '
	if hasDOB:
		s += 'dob, '
	if hasAddress:
		s += 'address, '
	if hasPhone:
		s += 'phone, '
	return s[:-2] + '\n'

def randLists():
	'''Returns a series of lists that are used to generate random data
	'''
	f = open('./static/random/firstNames.txt', 'r')
	firstNames = f.read().splitlines()
	f.close()
	f = open('./static/random/lastNames.txt', 'r')
	lastNames = f.read().splitlines()
	f.close()
	f = open('./static/random/streetSuffixes.txt', 'r')
	streetSuffixes = f.read().splitlines()
	f.close()
	f = open('./static/random/cities.txt', 'r')
	cities = f.read().splitlines()
	f.close()
	f = open('./static/random/states.txt', 'r')
	states = f.read().splitlines()
	f.close()
	domains = ['aol.com', 'gmail.com', 'hotmail.com',
	'mail.com' , 'mail.kz', 'yahoo.com']
	return firstNames, lastNames, streetSuffixes, cities, states, domains

def randCSV(
	category, numPeople, hasName, hasLevel, hasEmail, hasDOB,
	hasAddress, hasPhone, deleteEntries, probDeletion
	):
	# ID is generated by default.
	s = csvHeader(hasName, True, hasLevel, hasEmail, hasDOB, hasAddress, hasPhone)
	firstNames, lastNames, streetSuffixes, cities, states, domains = randLists()
	for i in range(numPeople):
		if hasName:
			name = [choice(firstNames), choice(lastNames)]
			s += ' '.join(name) + ', '
		s += str(i) + ', '
		if hasLevel:
			level = False
			if not deleteEntries or random() > probDeletion:
				if category == 'students':
					level = randint(9, 12)
				else:
					r = random()
					if r > 0.95:
						level = 'Assistant Principal'
					else:
						level = 'Teacher'
				s += str(level)
			s += ', '
		if hasEmail:
			if not deleteEntries or random() > probDeletion:
				# first letter of first name and part of last name,
				# followed by random email domain
				s += name[0][0].lower() + name[1][:randint(5, 7)].lower() + \
					'@' + choice(domains)
			s += ', '
		if hasDOB:
			if not deleteEntries or random() > probDeletion:
				# random date between 1/1/1998 and 12/28/2001
				s += str(randint(1, 12)) + '/' + str(randint(1, 28)) + \
					'/' + (str(2010 - level)
						if (hasLevel and level and category == 'students')
						else str(randint(1998, 2001)))
			s += ', '
		if hasAddress:
			if not deleteEntries or random() > probDeletion:
				# street address, city, state, zip
				s += str(randint(1, 9999)) + ' ' + choice(lastNames) + ' ' + \
					choice(streetSuffixes) + ' ' + choice(cities) + ' ' + \
					choice(states) + ' ' + str(randint(3000, 99999))
			s += ', '
		if hasPhone:
			if not deleteEntries or random() > probDeletion:
				# random phone number such that area code doesn't start
				# with a zero, none of the middle three digits are a 9, the
				# middle three digits aren't 000, and the last 4 digits
				# aren't identical
				n = '0000000000'
				while '9' in n[3:6] or n[3:6]=='000' or n[6]==n[7]==n[8]==n[9]:
					n = str(randint(10**9, 10**10-1))
				s += n[:3] + '-' + n[3:6] + '-' + n[6:]
			s += ', '
		s = s[:-2] + '\n'
	return s[:-1]

def upload_data(
	csv, category, numColumns, idCol, levelCol, emailCol,
	phoneCol, addressCol, dobCol, nameCol, fnameCol, lnameCol
	):
	has_header = Sniffer().has_header(csv.read(1024))
	csv.seek(0)
	# Find the delimiters and quote characters in the csv.
	dialect = Sniffer().sniff(csv.read(1024))
	csv.seek(0)
	csvreader = reader(csv, dialect)
	# Skip the header in the csv, if there is one.
	if has_header:
		next(csvreader)
	conn = connect('data.db')
	c = conn.cursor()
	for row in csvreader:
		# If there are more columns than the user said there would be, return
		# False to prevent index out of bounds errors.
		if int(numColumns) > len(row):
			return False
		# n is an attempt to reconstruct the full name
		n = row[int(nameCol) - 1] if nameCol else \
			' '.join(row[int(i) - 1] for i in [fnameCol, lnameCol] if i)
		header = csvHeader(
			n, idCol, levelCol, emailCol, dobCol, addressCol, phoneCol
			)
		q = 'INSERT OR REPLACE INTO %s (%s) VALUES (%s?)' % (
			category, header, header.count(',') * '?, '
			)
		arguments = ()
		if n:
			arguments += (n, )
		arguments += tuple(row[int(i) - 1] for i in [
			idCol, levelCol, emailCol, dobCol, addressCol, phoneCol
			] if i)
		c.execute(q, arguments)
	csv.close()
	return True
